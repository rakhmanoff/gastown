description = """
AGENT EXECUTION PROTOCOL - Towers of Hanoi ({disks} disks, {total_moves} steps)

PURPOSE: This is a durability proof, not computation. Steps are pre-computed.
Your job is to execute them mechanically, proving crash-recovery at scale.

EXECUTION LOOP:
1. Find current state: bd mol current <mol-id>
2. Find the next ready (unblocked) step
3. Close it: bd close <step-id>
4. Repeat until no ready steps remain

ON RESUME (after crash/restart/handoff):
- Same as fresh start. The molecule IS the state.
- Query `bd mol current <mol-id>`, continue from there.
- No memory of previous session needed.

DO:
- Close steps as fast as possible (they're trivial mechanical moves)
- Use `gt handoff` when context fills (proactive cycling)
- Trust the pre-computed solution - every move is already correct

DO NOT:
- Try to solve Hanoi yourself - moves are already computed
- Mark steps in_progress - just close them directly
- Ask for permission - this is GUPP territory, just execute
- Stop for human input - run autonomously until complete

MONITORING:
- Progress: Count closed children of the molecule
- For mega-molecules: Use convoy dashboard when available
- Completion: All steps closed = molecule complete

This proves Gas Town can execute arbitrarily long workflows with
nondeterministic idempotence - different sessions, same outcome.
"""
formula = "towers-of-hanoi"
version = 1

[example_3_disk]

[[example_3_disk.steps]]
description = "Move disk 1 from A to C"
id = "move-1"

[[example_3_disk.steps]]
description = "Move disk 2 from A to B"
id = "move-2"
needs = ["move-1"]

[[example_3_disk.steps]]
description = "Move disk 1 from C to B"
id = "move-3"
needs = ["move-2"]

[[example_3_disk.steps]]
description = "Move disk 3 from A to C"
id = "move-4"
needs = ["move-3"]

[[example_3_disk.steps]]
description = "Move disk 1 from B to A"
id = "move-5"
needs = ["move-4"]

[[example_3_disk.steps]]
description = "Move disk 2 from B to C"
id = "move-6"
needs = ["move-5"]

[[example_3_disk.steps]]
description = "Move disk 1 from A to C"
id = "move-7"
needs = ["move-6"]

[generate]
[generate.for-each]
range = "1..2^{disks}"
var = "move_num"
[generate.step]
description = "Move {computed_disk} from {computed_source} to {computed_target}. This is move {move_num} of {total_moves}. Simply execute the move - no decision needed."
id = "move-{move_num}"
needs = ["move-{move_num - 1}"]
[generate.step.compute]
disk = "lowest_set_bit({move_num})"
source = "peg_for_disk({disk}, {move_num}, 'source')"
target = "peg_for_disk({disk}, {move_num}, 'target')"

[[steps]]
description = "Verify initial state: {disks} disks stacked on peg {source_peg}. All disks in order (largest on bottom)."
id = "setup"

[[steps]]
description = "Execute all {total_moves} moves to transfer tower from {source_peg} to {target_peg}."
id = "solve"
needs = ["setup"]

[[steps]]
description = "Verify final state: all {disks} disks now on peg {target_peg}. Tower intact, all moves were legal."
id = "verify"
needs = ["solve"]

[vars]
[vars.auxiliary_peg]
default = "B"
description = "Helper peg"
[vars.disks]
description = "Number of disks to solve"
required = true
[vars.source_peg]
default = "A"
description = "Starting peg"
[vars.target_peg]
default = "C"
description = "Target peg"
